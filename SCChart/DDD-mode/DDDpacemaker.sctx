#resource "timing.h"
#hostcode-c "#include \"timing.h\""

scchart DDDpacemaker {
  
  // atrial sense atrial pace, ventricular sense and pace.
  
    // the reason why its throwing all these errors is because they are both trying to access the same variable?
    //pre()//use value from previosu tick 
    
    
    
    //to debug eitehr have a mac, or use the artifical heart from the board or use NIOSII
    // or write a C test bench in order to catch certain variables from it ,(Araon has some test stuff written up)
    
    // https://rtsys.informatik.uni-kiel.de/confluence/display/KIELER/SCCharts
    
  
  @ClocksUseSD
  input bool AS,VS
  //input int AVI_counter, AEI_counter, PVARP_counter,VRP_counter, LRI_counter, URI_counter // for hardware timer
  clock AVI_counter=0, AEI_counter=0, PVARP_counter=0,VRP_counter=0, LRI_counter=0, URI_counter = 0
  
  output bool AP, VP
  initial state top {
    bool AVI_start, AVI_stop
    bool AEI_start, AEI_stop
    bool LRI_start, LRI_stop
    bool PVARP_start, PVARP_stop
    bool VRP_start, VRP_stop
    bool URI_start, URI_stop
    bool AR, VR
    
    signal real_AS, real_VS
    
     region AVI{
      initial state init_AVI
      if pre(real_AS) ||pre(AP) do AVI_start = true; AVI_stop = false go to waitAVI

      state waitAVI
      if VS do AVI_stop = true; AVI_start = false; VP = false go to init_AVI //vs occurs
      if AVI_counter >= `AVI_VALUE` && pre(URI_start) go to waitAVIExtend
      if AVI_counter >= `AVI_VALUE` && pre(URI_stop) do VP = true; AVI_start = false; AVI_stop = true; AVI_counter=0 go to init_AVI
   
      
      state waitAVIExtend // If AVI finishes before URI extend the deadline to end of URI time
      if VS do AVI_stop = true; VP=false; AVI_start = false;AVI_counter=0 go to init_AVI
      if pre(URI_stop) do VP = true; AVI_stop = true; AVI_start = false; AVI_counter=0 go to init_AVI
      
      
    }
     region AVI_timer {
      initial state idle_AVI
      if pre(AVI_start) go to timeravi

      state timeravi
      if pre(AVI_stop) go to idle_AVI
     
    }
   
   region AEI{
     initial state init_AEI
     if pre(real_VS)|| pre(VP) do AEI_start = true; AEI_stop = false go to waitAEI

    state waitAEI
    if AS  do AEI_stop = true; AEI_start= false; AP=false go to init_AEI
    if AEI_counter >= `AEI_VALUE`  do AP = true; AEI_stop = true; AEI_start= false; AEI_counter=0 go to init_AEI
   }
   
   region AEI_Timer{
     initial state idle_AEI
     if AEI_start go to timeraei

     state timeraei
     if AEI_stop go to idle_AEI
       
 
   }
   
    region PVARP{
     initial state init_PVARP
     if VS || VP do PVARP_start = true; PVARP_stop = false go to wait_PVARP
     if AS do real_AS = true go to init_PVARP
     
     state wait_PVARP
     if AS  do AR = true go to wait_PVARP
     if PVARP_counter >=`PVARP_VALUE` do PVARP_stop = true; AR = false; PVARP_counter =0 go to init_PVARP
     
   }
     
   region PVARP_Timer{
     initial state idle_PVARP
      if pre(PVARP_start) go to timerpvarp

      state timerpvarp
      if pre(PVARP_stop) go to idle_PVARP
   }
     
   region VRP{
     initial state init_VRP
     if pre(PVARP_start) do VRP_start = true; VRP_stop = false go to wait_VRP
     if VS do real_VS = true go to init_VRP

    state wait_VRP
    if VS do VR = true go to wait_VRP
    if VRP_counter >= `VRP_VALUE` do VRP_stop = true; AP=false; VRP_start = false; VRP_counter= 0 go to init_VRP

     
   }
   region VRP_Timer{
     initial state idle_VRP
     if pre(VRP_start) go to timervrp
     
     state timervrp
     if pre(VRP_stop) go to idle_VRP
     
   }
   
      region LRI{
     initial state init_LRI
      if pre(real_VS) || pre(VP) do LRI_start = true; LRI_stop = false go to wait_LRI

     state wait_LRI
     if pre(real_VS) || pre(VP) do LRI_stop = true; LRI_start=false go to init_LRI    //again signify  the end
     if LRI_counter >= `LRI_VALUE` do LRI_stop = true; LRI_start=false;LRI_counter =0 go to init_LRI
     
     
     
   }
   
     region LRI_Timer{
     initial state idle_LRI
     if pre(LRI_start) go to timerlri
     
     state timerlri
     if pre(LRI_stop) go to idle_LRI
   }
   
      region URI{
     initial state init_URI
     if pre(real_VS) || pre(VP) do URI_start = true; URI_stop = false go to wait_URI
     
     state wait_URI
     if URI_counter >= `URI_VALUE` do URI_stop = true; URI_start=false; URI_counter =0 go to init_URI
     
     
   }
   
    region URI_Timer{
     initial state idle_URI
     if pre(URI_start) go to timeruri
     
     state timeruri
     if pre(URI_stop) go to idle_URI
     
   }
  }

}
