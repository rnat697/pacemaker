#resource "timing.h"
#hostcode-c "#include \"timing.h\""
@ClocksUseSD
scchart DDDpacemaker {
  
  // atrial sense atrial pace, ventricular sense and pace.
  
    // the reason why its throwing all these errors is because they are both trying to access the same variable?
    //pre()//use value from previosu tick 
    
    
    
    //to debug eitehr have a mac, or use the artifical heart from the board or use NIOSII
    // or write a C test bench in order to catch certain variables from it ,(Araon has some test stuff written up)
    
    // https://rtsys.informatik.uni-kiel.de/confluence/display/KIELER/SCCharts
    
  host "int" AVI_DEADLINE = `AVI_VALUE`
  host "int" URI_DEADLINE = `URI_VALUE`
  host "int" AEI_DEADLINE = `AEI_VALUE`
  host "int" LRI_DEADLINE = `LRI_VALUE`
  host "int" PVARP_DEADLINE = `PVARP_VALUE`
  host "int" VRP_DEADLINE = `VRP_VALUE`
  
  input bool AS,VS
  //input int AVI_counter, AEI_counter, PVARP_counter,VRP_counter, LRI_counter, URI_counter // for hardware timers
  clock AVI_counter, AEI_counter, PVARP_counter,VRP_counter, LRI_counter, URI_counter 
  
  output bool AP, VP
  initial state top {
    bool AVI_state
    bool AEI_state
    bool LRI_state
    bool PVARP_state
    bool VRP_state
    bool URI_state
    bool AR, VR
    signal AP_temp, VP_temp // temporary signals to indicate AP or VP has occurred
    
    signal real_AS, real_VS
    
     region AVI{
      initial state init_AVI 
      // Uses a previous value of AP_temp (1 tick delay)
      if !real_AS && !pre(AP_temp) do VP=false go to init_AVI // reset VP so its a pulse instead of square wave
      if real_AS || pre(AP_temp) do AVI_state = true; AVI_counter =0 go to waitAVI // Starts timer on AS or AP signals

      state waitAVI
      if real_VS do  AVI_state = false; VP = false go to init_AVI // Do not pace if VS occurs
      if ((AVI_counter >= AVI_DEADLINE) && (URI_state == true)) go to waitAVIExtend // extend the deadline if URI has not finished
      if ((AVI_counter >= AVI_DEADLINE) && (URI_state == false)) do VP = true; VP_temp; AVI_state = false go to init_AVI // pace ventricular
   
      
      state waitAVIExtend // If AVI finishes before URI extend the deadline to end of URI time
      if real_VS do  VP=false; AVI_state = false go to init_AVI // check for VS signal if there is any between the extended time
      if URI_state == false do VP = true; VP_temp;  AVI_state = false go to init_AVI // Once URI finishes, pace ventrical
      
      
    }
   
   region AEI{
     initial state init_AEI
     if !real_VS && !AP_temp do AP=false go to init_AEI // reset AP so its a pulse, not a square wave
     if real_VS || VP_temp do AEI_state = true; AEI_counter =0 go to waitAEI // starts timer on VS or VP signals

    state waitAEI
    if real_AS  do AEI_state= false; AP=false go to init_AEI // do not pace if AS occurs
    if AEI_counter >= AEI_DEADLINE  do AP = true; AP_temp; AEI_state= false go to init_AEI // pace atiral when AEI finishes
   }
  
   
    region PVARP{
     initial state init_PVARP
     // Uses previous value of VP_temp (1 tick delay)
     if VS || pre(VP_temp) do PVARP_state= true; PVARP_counter = 0 go to wait_PVARP // starts timer on VS or VP signal
     if AS do real_AS go to init_PVARP // sets the real_AS signal if timer hasn't stated yet
     
     state wait_PVARP
     if AS  do AR = true go to wait_PVARP // Ignores AS signal when it occurs during the timer's duration
     if PVARP_counter >=PVARP_DEADLINE do PVARP_state = false; AR = false go to init_PVARP // stops timer
     
   }
     
   region VRP{
     initial state init_VRP
     // Uses previous value of VP_temp (1 tick delay)
     if VS || pre(VP_temp) do real_VS; VRP_state = true; VRP_counter = 0 go to wait_VRP // On timer start, set the real_VS signal

    state wait_VRP
    if VS do VR = true go to wait_VRP // ignore any VS signals in the duration of the timer
    if VRP_counter >= VRP_DEADLINE do VR=false; VRP_state = false go to init_VRP // stops timer
   
   }
   
      region LRI{
     initial state init_LRI
     // Uses previous value of VP_temp (1 tick delay)
      if VS || pre(VP_temp) do LRI_state = true; LRI_counter = 0 go to wait_LRI // starts timer on VS or VP signals

     state wait_LRI
     if VS || pre(VP_temp) do LRI_state=false go to init_LRI    // stops timer on VS or VP signal
     if LRI_counter >= LRI_DEADLINE do  LRI_state=false go to init_LRI // No VS or VP signal, run timer until the end of its duration
     
     
     
   }
   
      region URI{
     initial state init_URI
     // Uses previous value of VP_temp (1 tick delay)
     if real_VS || pre(VP_temp) do URI_state = true; URI_counter = 0 go to wait_URI // starts timer on VS or VP signals
     
     state wait_URI
     if URI_counter >= URI_DEADLINE do URI_state=false go to init_URI // stops timer 
     
     
   }
 
  }

}
